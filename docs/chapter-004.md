
## Chapter 4. 클래스, 객체, 인터페이스

* 코틀린의 클래스와 인터페이스는 자바와 약간 다르다.
* 자바와 달리 코틀린 선언은 기본적으로 final이며 public이다.
* 중첩 클래스는 기본적으로 내부 클래스가 아니다.
    * 코틀린의 중첩 클래스에는 외부 클래스에 대한 참조가 없다.
* 코틀린 컴파일러는 번잡스러움을 피하기 위해 유용한 메소드를 자동으로 만들어준다.
* 클래스를 data로 선언하면 컴파일러가 일부 표준 메소드를 생성해준다.
* 코틀린 언어가 제공하는 위임(delegation)을 사용하면 위임을 처리하기 위한 준비 메소드를 직접 작성할 필요가 없다.

### 4.1. 클래스 계층 정의

* 코틀린 가시성/접근 변경자는 자바와 비슷하지만 아무것도 지정하지 않은 경우 기본 가시성은 다르다.
* 코틀린에 새로 도입한 sealed 변경자에 대해 알아본다.

#### 4.1.1. 코틀린 인터페이스

* 코틀린 인터페이스는 자바 8 인터페이스와 비슷하다.
* 추상 메소드뿐 아니라 구현이 있는 메소드도 정의할 수 있다.
    * 자바의 디폴트 메소드와 비슷하다.
* 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

```kotlin
package blog.`in`.action

interface Clickable {

    fun click()
}
```

* 자바에서는 extends, implements 키워드를 사용하지만, 코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.
* 클래스는 인터페이스를 원하는 만큼 개수 제한 없이 마음대로 구현할 수 있다.
* 클래스는 오로지 하나만 확장할 수 있다.
* 자바와 달리 코틀린에서 override 변경자는 반드시 사용해야 한다.
    * 실수로 상위 클래스의 메소드를 오버라이드하는 것을 방지해준다.
    * 상위 클래스에 있는 메소드와 시그니처가 같은 메소드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 되지 않기 때문에 overrid를 붙이거나 메소드 이름을 바꿔야만 한다.

```kotlin
package blog.`in`.action

class Button : Clickable {

    override fun click() {
        println("I was clicked")
    }
}

fun main() {
    Button().click()
}
```

* 인터페이스 메소드도 디폴트 구현을 제공할 수 있다.
    * default를 붙여야 하는 자바 8과 달리 코틀린에서는 메소드를 특별한 키워드로 꾸미지 않는다.
    * 단순히 메소드 본문을 시그니처 뒤에 추가하면 된다.
* click 메소드는 반드시 재정의가 필요하지만, showOff 메소드는 재정의를 생략해서 디폴트 구현을 사용해도 무관하다.

```kotlin
package blog.`in`.action

interface Clickable {

    fun click()
    fun showOff() = println("I am Clickable show off") // default method
}
```

```kotlin
package blog.`in`.action

interface Focusable {
    fun setFocus(boolean: Boolean) {
        println("I ${if (boolean) "got" else "lost"} focus.")
    }

    fun showOff() = println("I am Focusable show off")
}
```

* 동시에 두 개 이상의 인터페이스를 구현할 떄 인터페이스에 동일한 시그니처 메소드가 존재하면 컴파일 에러가 발생한다.
* 클래스에서 해당 메소드를 재정의하면 문제는 해결된다.
* 인터페이스의 디폴트 메소드를 호출하는 것도 가능하다.

```kotlin
package blog.`in`.action

class Button : Clickable, Focusable {

    override fun click() {
        println("I was clicked")
    }

    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
        println("I am show off in Button")
    }
}

fun main() {
    val button = Button()
    button.click()
    button.showOff()
}
```

#### 4.1.2. open, final, abstract 변경자

* 자바는 final 키워드가 명시적으로 붙지 않은 경우 모두 상속이 가능하다.
* 편리하기도 하지만, 문제가 생기는 경우도 많다.
* 취약한 기반 클래스(fragile base class)라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다.
* 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 있다.
* 모든 하위 클래스를 분석하는 것은 불가능하다.
* 기반 클래스를 변경하는 경우 하위 크래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 취약하다.
* 특별히 하위 클래스에서 오버라이드하게 의도된 클래스와 메소드가 아니라면 모두 final로 만드는 것이 안정적이다.

```kotlin
package blog.`in`.action

open class RichButton: Clickable { // open 키워드로 클래스 상속을 허용한다.

    fun disable() {
        // 파이널 함수
        // 하위 클래스가 이 메소드를 오버라이드할 수 없다.
    }

    open fun animate() {
        // 열린 함수
        // 하위 클래스에서 이 메소드를 오버라이드 할 수 있다.
    }

    override fun click() {
        // 상위 클래스에서 선언된 열린 메소드를 오버라이드 한다.
        // 오버라이드한 메소드는 기본적으로 열려있다.
    }
}
```

* 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메소드는 기본적으로 열려있다. 
* 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 메소드 앞에 final 키워드를 명시한다.
    * override 키워드가 붙은 메소드는 기본적으로 열려있다.
    * final을 붙혀 하위 클래스가 이를 확장하지 못 하도록 막는다.

```kotlin
open class RichButton: Clickable {
    final override fun click() {}
}
```

* 열린 클래스와 스마트 캐스트
    * 클래스는 기본적으로 상속 가능 상태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.
    * 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다.
    * 클래스 프로퍼티의 경우 val 이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 쓸 수 있다는 의미이다.
    * 이는 프로퍼티가 final 이어야 한다는 의미이기도 하다.
    * 프로퍼티가 final이 아니라면 그 프로퍼티를 다른 클래스가 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구 사항을 깰 수 있다.

* 자바처럼 클래스를 abstract로 선언할 수 있다.
    * 선언한 추상 클래스는 인스턴스화 할 수 없다.
    * 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드해야 한다.
* 추상 멤버는 항상 열려있다.
* 추상 멤버 앞에 open 변경자를 명시할 필요가 없다.

```kotlin
package blog.`in`.action

abstract class Animated { // 이 클래스는 추상 클래스이다. 인스턴스를 만들 수 없다.

    abstract fun animate() // 추상 함수이다. 하위 클래스에서 이 함수를 반드시 오버라이드해야 한다.

    open fun stopAnimate() {
        // 추상 클래스에 속헀더라도 비추상함수는 기본적으로 final
        // 원한다면 open으로 오버라이드를 허용할 수 있다.
    }

    fun animateTwice() {
        // 추상 클래스에 속헀더라도 비추상함수는 기본적으로 final
    }
}
```

* 표로 표현하면 다음과 같다.

|변경자|멤버|설명|
|:-|:-|:-|
|fianl|오버라이드 할 수 없음|클래스 멤버 기본 변경자|
|open|오버라이드 할 수 있음|반드시 open을 명시해야 오버라이드 가능|
|abstract|반드시 오버라이드해야 함|추상 클래스의 멤버에만 이 변경자를 붙힐 수 있다. 추상 멤버에는 구현이 있으면 안된다.|
|override|상위 클래스나 인스턴의 멤버를 오버라이드 하는 중|오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 방지하려면 final 키워드를 명시하면 된다.|

#### 4.1.3. 가시성 변경자(visibility modifier)

* 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.
    * 어떤 클래스의 구현에 대한 접근을 제한한다.
    * 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다.
* 기본적으로 코틀린의 가시성 변경자는 자바와 비슷하다.
    * public, protected, private
* 아무 변경자도 없는 경우 선언은 모두 공개(public)이다.
* 자바의 기본 가시성인 패키지 전용(package-private)은 코틀린에 없다.
* 코틀린을 패키지를 네임스페이스(namespace)를 관리하기 위한 용도로만 사용한다.
    * 패키지를 가시성 제어에 사용하지 않는다.
* 코틀린은 패키지 전용 가시성에 대한 대안으로 internal이라는 변경자를 사용한다.
    * 모듈 내부에서만 볼 수 있다.
* 모듈(module)은 한 번에 한꺼먼에 컴파일되는 코틀린 파일들을 의미한다.
    * 인텔리J, 이클립스, 메이븐, 크레이들 등의 프로젝트가 모듈이 될 수 있다.
    * 앤트 태스크(task)가 한 번 실행될 때 함께 컴파일되는 파일의 집합도 모듈이 될 수 있다.
* 모듈 내부 가시성은 모듈 구현에 대한 진정한 캡슐화를 제공한다는 장점이 있다.
    * 자바에서는 패키지가 같은 클래스를 선언하기만 하면 어떤 프로젝트의 외부에 있는 코드라도 패키지 내부에 있는 패키지 전용 선언에 쉽게 접근 가능하다.
    * 모듈의 캡슐화가 쉽게 깨진다.
* 코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다.
* 최상위 선언에는 클래스, 함수, 프로퍼티 등이 포함된다.
* 비공개 가시성인 최상위 선언은 그 선언이 들어있는 파일 내부에서만 사용할 수 있다.
    * 최상위 선언된 함수, 프로퍼티, 클래스는 해당 파일에서만 접근 가능하다.
    * 하위 시스템의 자세한 구현 사항을 외부에 감추고 싶을 때 유용한 방법이다.

* 코틀린의 가시성 변경자

|변경자|클래스 멤버|최상위 선언|
|:-|:-|:-|
|public(기본 가시성)|모든 곳에서 볼 수 있다.|모든 곳에서 볼 수 있다.|
|internal|같은 모듈 안에서만 볼 수 있다.|같은 모듈 안에서만 볼 수 있다.|
|protected|하위 클래스 안에서만 볼 수 있다.|최상위 선언에 적용할 수 없다.|
|private|같은 클래스 안에서만 볼 수 있다.|같은 파일 안에서만 볼 수 있다.|

* 다음 예제는 가시성 규칙 위반 사례들이다.
    * 컴파일 시점에 오류가 감지된다.

```kotlin
internal open class TalkativeButton: Focusable {
    private fun yell() = println("Hey")
    protected fun whisper() = println("Let's talk")
}

fun TalkativeButton.giveSpeech() { // public 멤버가 자신의 internal 수신 타입인 TalkativeButton을 노출한다.
    yell() // public 확장 함수는 private yell에 접근할 수 없다.
    whisper() // public 확장 함수는 protected whisper에 접근할 수 없다.
}
```

* 코틀린은 public 확장 함수에서 그보다 가시성이 낮은 internal 타입인 TalkativeButton을 참조하지 못하게 한다.
* 가시성이 더 낮은 경우 참조하지 못한다.
    * 일반적으로 높거나 같은 경우에만 참조가 가능하다.
* 자바는 protected인 경우 같은 패키지에서 접근 가능했지만, 코틀린은 그렇지 않다.
* 클래스를 확장한 함수는 그 클래스의 private, protected 멤버에 접근할 수 없다.

* 코틀린의 가시성 변경자와 자바
    * 코틀린의 public, protected, private 변경자는 컴파일 된 자바 바이트 코드 안에서도 그대로 유지된다.
    * 컴파일 된 코틀린 선언의 가시성은 자바에서 똑같은 가시성을 사용해 선언한 경우와 같다.
    * private 클래스는 예외이다.
    * 자바에서 클래스는 private으로 만들 수 없다.
    * 내부적으로 코틀린은 private 클래스를 패키지-전용 클래스로 컴파일한다.
    * internal 변경자는 자바에 딱 맞는 가시성이 없다.
    * internal 변경자는 바이트 코드 상에서는 public이 된다.
    * 다른 모듈에 정의된 internal 클래스나 internal 최상위 선언은 모듈 외부의 자바 코드에서 접근할 수 있다.
    * 코틀린에서 protected로 정의한 멤버를 코틀린 클래스와 같은 패키지의 자바 코드에서 접근할 수 있다.
    * 코틀린 컴파일러는 internal 가시성 멤버의 이름을 보기 나쁘게 변경한다.(mangle)

#### 4.1.4. 내부 클래스와 중첩된 클래스

* 자바처럼 코틀린에서도 클래스 안에 다른 클래스를 선언할 수 있다.
* 클래스 안에 다른 클래스를 선언하면 도우미 클래스를 캡슐화하거나 코드 정의를 그 코드를 사용하는 곳에 가까이 두고 싶을 때 유용하다.
* 자바와의 차이는 코틀린의 중첩 클래스(nested class)는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다는 점이다.

* 자바 코드의 경우 중첩 클래스의 직렬화는 다음과 같은 문제가 있다.

```java

```